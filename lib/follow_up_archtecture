lib/
├── core/
│   ├── config/          # Theme, constants, localization
│   ├── network/         # API clients, interceptors
│   ├── utils/           # Helpers, validators, extensions
│   └── services/        # Auth, Firebase, etc.
│
├── data/
│   ├── models/          # Model classes (User, Agency, Package, etc.)
│   ├── repositories/    # Abstractions and implementations
│   └── datasources/     # Remote & local data sources
│
├── domain/
│   ├── entities/        # Pure business logic models
│   └── usecases/        # Application-specific business rules
│
├── presentation/
│   ├── cubits/          # Cubits/States (organized by feature)
│   ├── views/           # Screens (UI only)
│   ├── widgets/         # Shared widgets
│   └── routes/          # Navigation and route handling
│
└── main.dart
import 'package:get/get.dart';
import '../../../domain/usecases/send_message_usecase.dart';

class MistralController extends GetxController {
  var responseText = "Type something and press Ask Mistral...".obs;
  var isLoading = false.obs;

  final SendMessageUseCase sendMessageUseCase;

  // Inject the use case via constructor
  MistralController(this.sendMessageUseCase);

  Future<bool> callMistral({
    required String prompt,
    required String language,
    required String tone,
    required String length,
  }) async {
    isLoading.value = true;
    responseText.value = "⏳ Thinking...";

    // 📝 Build instruction string for AI
    final instruction = """
Write an email in $language with a $tone tone and $length length.
Here is the user's draft content: "$prompt"
""";

    // 🎚 Decide maxTokens based on length
    final maxTokens = length.toLowerCase() == "short"
        ? 50
        : length.toLowerCase() == "medium"
            ? 100
            : 200;

    try {
      // ✅ Call the use case
      final aiResponse =
          await sendMessageUseCase(instruction, maxTokens: maxTokens);

      responseText.value = aiResponse;
      return true;
    } catch (e) {
      responseText.value = "❌ Exception: $e";
      return false;
    } finally {
      isLoading.value = false;
    }
  }
}
